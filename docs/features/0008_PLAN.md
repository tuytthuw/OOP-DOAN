# Kế Hoạch Kỹ Thuật #0008 - Xây Dựng Business Logic Services

## ⚠️ TUÂN THỨ: Dùng Mảng T[], Không dùng List/ArrayList

## 1. Mô Tả Ngữ Cảnh

Tạo các lớp Service chứa logic xử lý nghiệp vụ (Business Logic) cho ứng dụng spa. Các Service này sẽ tương tác với các Manager để thực hiện các thao tác phức tạp.

**Nguyên tắc:** Tất cả phương thức trả về `T[]` (mảy), KHÔNG dùng `List<T>`

---

## 2. Các Tệp và Hàm Liên Quan

### Tệp TẠO MỚI:

- `src/main/java/services/CustomerService.java` - Logic quản lý khách hàng
- `src/main/java/services/AppointmentService.java` - Logic quản lý lịch hẹn
- `src/main/java/services/InvoiceService.java` - Logic tính toán hóa đơn
- `src/main/java/services/PaymentService.java` - Logic xử lý thanh toán
- `src/main/java/services/ReportService.java` - Logic thống kê báo cáo

### Tệp THAY ĐỔI:

- `src/main/java/services/Init.java` - Thêm khởi tạo tất cả services

---

## 3. Thuật Toán / Logic (Từng Bước)

### 3.1 CustomerService - Quản Lý Khách Hàng

**Phương thức:**

- `registerNewCustomer(fullName, phoneNumber, email, address): Customer` - Đăng ký khách hàng mới
- `updateCustomerInfo(customerId, fullName, phoneNumber, email, address): boolean` - Cập nhật thông tin
- `updateCustomerTier(customerId): void` - Cập nhật tier dựa trên totalSpent
- `addSpendingToCustomer(customerId, amount): void` - Cộng chi tiêu khi thanh toán
- `deactivateCustomer(customerId): boolean` - Vô hiệu hóa khách hàng
- `reactivateCustomer(customerId): boolean` - Kích hoạt lại khách hàng

**Logic `registerNewCustomer()`:**

1. Kiểm tra phoneNumber hoặc email không trùng lặp (dùng Manager.getAll() trả về Customer[])
2. Sinh ID mới: `customerId = "CUST_" + (timestamp hoặc sequential ID)`
3. Tạo Customer mới với Tier mặc định là BRONZE
4. Thêm vào CustomerManager (Manager.add(customer))
5. Trả về Customer vừa tạo

**✅ Ví dụ Code:**

```java
public Customer registerNewCustomer(String fullName, String phoneNumber,
                                     String email, String address) {
    // Kiểm tra duplicate - dùng mảy từ Manager
    Customer[] existingCustomers = customerManager.getAll();
    for (Customer c : existingCustomers) {
        if (c.getPhoneNumber().equals(phoneNumber)) {
            throw new ValidationException("Số điện thoại đã tồn tại");
        }
    }

    Customer newCustomer = new Customer(...);
    customerManager.add(newCustomer);
    return newCustomer;
}
```

**Logic `updateCustomerTier(customerId)`:**

1. Lấy Customer theo ID
2. Gọi phương thức `updateTier()` của Customer
3. Cập nhật lại trong CustomerManager

---

### 3.2 AppointmentService - Quản Lý Lịch Hẹn

**Phương thức:**

- `bookAppointment(customerId, serviceId, appointmentDateTime): Appointment` - Đặt lịch hẹn mới
- `cancelAppointment(appointmentId): boolean` - Hủy lịch hẹn
- `rescheduleAppointment(appointmentId, newDateTime): boolean` - Sắp xếp lại lịch
- `startAppointment(appointmentId): boolean` - Bắt đầu dịch vụ
- `completeAppointment(appointmentId): boolean` - Hoàn thành dịch vụ
- `assignStaffToAppointment(appointmentId, staffId): boolean` - Gán nhân viên
- `getCustomerAppointmentHistory(customerId): Appointment[]` - Lịch sử lịch hẹn (trả về mảy)

**Logic `getCustomerAppointmentHistory(customerId): Appointment[]`:**

```java
// ✅ Trả về mảy, không dùng List
public Appointment[] getCustomerAppointmentHistory(String customerId) {
    Appointment[] allAppointments = appointmentManager.getAll();
    Appointment[] result = new Appointment[allAppointments.length];
    int count = 0;

    for (Appointment apt : allAppointments) {
        if (apt.getCustomerId().equals(customerId)) {
            result[count++] = apt;
        }
    }

    // Trả về mảy con chỉ chứa kết quả
    Appointment[] finalResult = new Appointment[count];
    for (int i = 0; i < count; i++) {
        finalResult[i] = result[i];
    }
    return finalResult;
}
```

**Logic `bookAppointment(customerId, serviceId, appointmentDateTime)`:**

1. Kiểm tra Customer tồn tại
2. Kiểm tra Service tồn tại
3. Kiểm tra appointmentDateTime không trong quá khứ
4. Kiểm tra không có xung đột lịch (nếu cần)
5. Sinh ID mới: `appointmentId = "APT_" + timestamp`
6. Tạo Appointment mới với status SCHEDULED
7. Thêm vào AppointmentManager
8. Trả về Appointment

**Logic `completeAppointment(appointmentId)`:**

1. Lấy Appointment theo ID
2. Kiểm tra status là SPENDING
3. Gọi phương thức `markAsCompleted()` của Appointment
4. Cập nhật lastVisitDate của Customer
5. Cập nhật lại trong AppointmentManager
6. Trả về true

---

### 3.3 InvoiceService - Tính Toán Hóa Đơn

**Phương thức:**

- `createInvoiceForAppointment(appointmentId, paymentMethod): Invoice` - Tạo hóa đơn
- `applyDiscountToInvoice(invoiceId, discountCode): boolean` - Áp dụng chiết khấu
- `calculateFinalAmount(invoiceId): BigDecimal` - Tính tổng tiền cuối cùng
- `getInvoiceDetails(invoiceId): String` - Lấy chi tiết hóa đơn

**Logic `createInvoiceForAppointment(appointmentId, paymentMethod)`:**

1. Lấy Appointment theo ID
2. Lấy Service từ Appointment
3. Lấy giá từ Service: `basePrice`
4. Sinh ID mới: `invoiceId = "INV_" + timestamp`
5. Tạo Invoice với `subtotal = basePrice`
6. Cập nhật thông tin: `customerId`, `paymentMethod`
7. Tính thuế (10%): gọi `calculateTax(10)`
8. Tính tổng: gọi `calculateTotal()`
9. Thêm vào InvoiceManager
10. Trả về Invoice

**Logic `applyDiscountToInvoice(invoiceId, discountCode)`:**

1. Lấy Invoice theo ID
2. Tìm Discount theo mã trong DiscountManager
3. Kiểm tra Discount hợp lệ: gọi `canUse()`
4. Tính tiền chiết khấu: gọi `calculateDiscount(subtotal)`
5. Áp dụng vào Invoice: gọi `applyDiscount(discountAmount, discountCode)`
6. Cập nhật Invoice trong InvoiceManager
7. Tăng lượt sử dụng Discount: gọi `incrementUsage()`
8. Trả về true

---

## 4. Ghi Chú Kỹ Thuật & Compliance

### ❌ KHÔNG DÙNG:

```java
import java.util.List;
import java.util.ArrayList;
List<Appointment> history = new ArrayList<>();
```

### ✅ PHẢI DÙNG:

```java
// Trả về mảy từ Manager
Appointment[] history = appointmentManager.getAll();

// Lọc dữ liệu dùng vòng for thường
Appointment[] filtered = new Appointment[history.length];
int count = 0;
for (Appointment apt : history) {
    if (apt.getCustomerId().equals(customerId)) {
        filtered[count++] = apt;
    }
}
Appointment[] result = new Appointment[count];
for (int i = 0; i < count; i++) {
    result[i] = filtered[i];
}
```

### Quy tắc OOP cho Service Layer:

1. **Dependency Injection**: Các Manager được truyền vào constructor
2. **Business Logic**: Service chứa logic xử lý, không trực tiếp tương tác với DB
3. **Exception Handling**: Throw custom exceptions từ kế hoạch 0012
4. **Array Only**: Tất cả phương thức trả về T[], không dùng List/ArrayList
5. **Comment**: Javadoc + comment tiếng Việt cho logic phức tạp

---

## 5. Tệp Cần Tạo / Thay Đổi

### ✅ Tệp TẠO MỚI:

- `src/main/java/services/CustomerService.java`
- `src/main/java/services/AppointmentService.java`
- `src/main/java/services/InvoiceService.java`
- `src/main/java/services/PaymentService.java`
- `src/main/java/services/ReportService.java`

### ✅ Tệp THAY ĐỔI:

- `src/main/java/services/Init.java` - Thêm khởi tạo tất cả services

**Phương thức:**

- `processPaymentForInvoice(invoiceId, paymentMethod): Transaction` - Thanh toán hóa đơn
- `recordTransaction(appointmentId, customerId, amount, paymentMethod): Transaction` - Ghi nhận giao dịch
- `refundTransaction(transactionId, refundAmount): boolean` - Hoàn tiền
- `getPaymentStatus(transactionId): String` - Kiểm tra trạng thái thanh toán

**Logic `processPaymentForInvoice(invoiceId, paymentMethod)`:**

1. Lấy Invoice theo ID
2. Kiểm tra Invoice chưa thanh toán
3. Lấy số tiền: `amount = totalAmount` của Invoice
4. Sinh ID mới: `transactionId = "TXN_" + timestamp`
5. Tạo Transaction mới với status PENDING
6. Gọi phương thức `processPayment()` của Transaction (status → SUCCESS)
7. Thêm vào TransactionManager
8. Đánh dấu Invoice đã thanh toán: gọi `markAsPaid(today)`
9. Cộng chi tiêu vào Customer: `addSpendingToCustomer(customerId, amount)`
10. Cập nhật Tier Customer: `updateCustomerTier(customerId)`
11. Trả về Transaction

---

### 3.5 ReportService - Thống Kê & Báo Cáo

**Phương thức:**

- `getTotalRevenueByDateRange(startDate, endDate): BigDecimal` - Tổng doanh thu
- `getCustomerCountByTier(tier): int` - Số lượng khách hàng theo tier
- `getAppointmentCountByStatus(status): int` - Số lượng lịch hẹn theo trạng thái
- `getTopCustomersBySpending(limit): List<Customer>` - Top khách hàng chi tiêu nhiều
- `getMostPopularService(): Service` - Dịch vụ được yêu thích nhất
- `getMonthlyRevenue(year, month): BigDecimal` - Doanh thu theo tháng
- `getPaymentMethodStatistics(): Map<PaymentMethod, BigDecimal>` - Thống kê phương thức thanh toán

**Logic `getTotalRevenueByDateRange(startDate, endDate)`:**

1. Lấy tất cả Invoice từ InvoiceManager
2. Lọc những Invoice có issueDate nằm trong [startDate, endDate]
3. Lọc những Invoice đã thanh toán (`isPaid = true`)
4. Tính tổng: `sum(totalAmount)` của tất cả Invoice
5. Trả về tổng

---

## 4. Ghi Chú Kỹ Thuật

- Các Service nên được khởi tạo với các Manager liên quan
- ID tự động sinh có thể dùng `System.currentTimeMillis()` hoặc atomic counter
- Tất cả phương thức nên kiểm tra dữ liệu null trước khi sử dụng
- Sử dụng các Enum (AppointmentStatus, DiscountType, PaymentMethod, etc.)
- Nên có logging để ghi nhận các thao tác quan trọng (tùy chọn)
- Comment bằng tiếng Việt cho Javadoc và logic phức tạp
